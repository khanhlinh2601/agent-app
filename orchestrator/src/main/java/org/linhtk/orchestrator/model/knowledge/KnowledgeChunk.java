package org.linhtk.orchestrator.model.knowledge;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.annotations.Type;
import org.hibernate.type.SqlTypes;
import org.linhtk.common.model.AbstractAuditEntity;
import org.linhtk.orchestrator.config.hibernate.VectorType;

import java.util.HashMap;
import java.util.Map;

/**
 * Entity representing chunked content from knowledge sources.
 * Stores processed text content with vector embeddings for semantic search.
 * Each chunk represents a portion of the original knowledge source content
 * optimized for AI retrieval and context injection.
 */
@Entity
@Table(name = "knowledge_chunk")
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@Builder
public class KnowledgeChunk extends AbstractAuditEntity {
    
    /**
     * Unique identifier for the knowledge chunk.
     * Generated as UUID for distributed system compatibility.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    /**
     * Reference to the parent knowledge source that this chunk belongs to.
     * Stored as UUID string without foreign key constraint for flexibility.
     */
    @Column(name = "agent_knowledge_id", nullable = false, length = 50)
    private String agentKnowledgeId;

    /**
     * Reference to the agent that owns this knowledge chunk.
     * Denormalized for faster querying without joins.
     */
    @Column(name = "agent_id", nullable = false, length = 50)
    private String agentId;
    
    /**
     * Sequential order of this chunk within the parent knowledge source.
     * Used to maintain original document structure and enable ordered retrieval.
     * Defaults to 0 for single-chunk knowledge sources.
     */
    @Column(name = "chunk_order", nullable = false)
    @Builder.Default
    private Integer chunkOrder = 0;

    /**
     * Text content of this knowledge chunk.
     * Stored as TEXT to accommodate large content blocks.
     * This is the actual content that will be used for AI context injection.
     */
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    /**
     * JSON metadata for storing chunk-specific information.
     * May include processing parameters, source location, confidence scores, etc.
     * Uses PostgreSQL JSONB for efficient storage and querying.
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    @Builder.Default
    private Map<String, Object> metadata = new HashMap<>();

    /**
     * 768-dimensional vector embedding for semantic search.
     * Generated by smaller embedding models (e.g., sentence-transformers).
     * Null when embeddings haven't been generated or model doesn't support this dimension.
     */
    @Column(name = "embedding_768")
    @Type(VectorType.class)
    private float[] embedding768;

    /**
     * 1536-dimensional vector embedding for semantic search.
     * Generated by larger embedding models (e.g., OpenAI text-embedding-ada-002).
     * Null when embeddings haven't been generated or model doesn't support this dimension.
     */
    @Column(name = "embedding_1536")
    @Type(VectorType.class)
    private float[] embedding1536;
}
